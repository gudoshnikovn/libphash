This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
- Git diffs from the worktree and staged changes are included
</notes>

</file_summary>

<directory_structure>
include/
  libphash.h
src/
  hashes/
    ahash.c
    bmh.c
    color_hash.c
    common.c
    dhash.c
    mhash.c
    phash.c
    radial.c
    whash.c
  core.c
  image.c
  internal.h
tests/
  photo_color_changed.jpeg
  photo_copy.jpeg
  photo_rotated_90.jpeg
  photo.jpeg
  test_bmh.c
  test_color.c
  test_core.c
  test_hashes.c
  test_image_hashes.c
  test_internal.c
  test_mhash.c
  test_radial.c
  test_whash.c
.gitignore
LICENSE
Makefile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/hashes/mhash.c">
#include "../internal.h"
#include <stdlib.h>

PH_API ph_error_t ph_compute_mhash(ph_context_t *ctx, uint64_t *out_hash) {
  if (!ctx || !ctx->is_loaded || !out_hash)
    return PH_ERR_INVALID_ARGUMENT;

  // 1. Resize to 16x16 to capture structural edges
  uint8_t tiny[256];
  uint8_t *full_gray = malloc(ctx->width * ctx->height);
  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
  ph_resize_grayscale(full_gray, ctx->width, ctx->height, tiny, 16, 16);
  free(full_gray);

  // 2. Simple 3x3 Laplacian Kernel for edge detection
  //  0 -1  0
  // -1  4 -1
  //  0 -1  0
  uint64_t hash = 0;
  int bit_idx = 0;
  for (int y = 1; y < 15 && bit_idx < 64; y += 2) {
    for (int x = 1; x < 15 && bit_idx < 64; x += 2) {
      int center = tiny[y * 16 + x] * 4;
      int neighbors = tiny[(y - 1) * 16 + x] + tiny[(y + 1) * 16 + x] +
                      tiny[y * 16 + (x - 1)] + tiny[y * 16 + (x + 1)];
      if (center - neighbors > 0)
        hash |= (1ULL << bit_idx);
      bit_idx++;
    }
  }
  *out_hash = hash;
  return PH_SUCCESS;
}
</file>

<file path="tests/test_mhash.c">
#include "libphash.h"
#include "test_macros.h"
#include <stdio.h>

void test_mhash_logic() {
  ph_context_t *ctx = NULL;
  uint64_t hash_orig = 0, hash_mod = 0;

  ASSERT_OK(ph_create(&ctx));

  // Test 1: Base image
  ASSERT_OK(ph_load_from_file(ctx, "tests/photo.jpeg"));
  ASSERT_OK(ph_compute_mhash(ctx, &hash_orig));

  // Test 2: Color changed image (MHash should be resistant to this as it tracks
  // edges)
  ASSERT_OK(ph_load_from_file(ctx, "tests/photo_color_changed.jpeg"));
  ASSERT_OK(ph_compute_mhash(ctx, &hash_mod));

  int dist = ph_hamming_distance(hash_orig, hash_mod);
  printf("[MHash] Original: %llu, Color-Changed: %llu, Distance: %d\n",
         (unsigned long long)hash_orig, (unsigned long long)hash_mod, dist);

  // MHash tracks structural edges, so color shifts shouldn't change the edge
  // skeleton much
  if (dist > 12) {
    fprintf(stderr, "MHash failed: too sensitive to color changes (dist: %d)\n",
            dist);
    exit(1);
  }

  ph_free(ctx);
  printf("test_mhash: PASSED\n");
}

int main() {
  test_mhash_logic();
  return 0;
}
</file>

<file path="tests/test_whash.c">
#include "libphash.h"
#include "test_macros.h"
#include <stdio.h>

void test_whash_logic() {
  ph_context_t *ctx1 = NULL;
  ph_context_t *ctx2 = NULL;
  uint64_t hash1 = 0, hash2 = 0;

  ASSERT_OK(ph_create(&ctx1));
  ASSERT_OK(ph_create(&ctx2));

  // Load original and a copy
  ASSERT_OK(ph_load_from_file(ctx1, "tests/photo.jpeg"));
  ASSERT_OK(ph_load_from_file(ctx2, "tests/photo_copy.jpeg"));

  ASSERT_OK(ph_compute_whash(ctx1, &hash1));
  ASSERT_OK(ph_compute_whash(ctx2, &hash2));

  int dist = ph_hamming_distance(hash1, hash2);
  printf("[WHash] Hash: %llu, Distance: %d\n", (unsigned long long)hash1, dist);

  // WHash is very stable for copies
  if (dist > 5) {
    fprintf(stderr, "WHash distance too high for identical images: %d\n", dist);
    exit(1);
  }

  ph_free(ctx1);
  ph_free(ctx2);
  printf("test_whash: PASSED\n");
}

int main() {
  test_whash_logic();
  return 0;
}
</file>

<file path="src/hashes/ahash.c">
#include "../internal.h"
#include <stdlib.h>

PH_API ph_error_t ph_compute_ahash(ph_context_t *ctx, uint64_t *out_hash) {
  if (!ctx || !ctx->is_loaded || !out_hash)
    return PH_ERR_INVALID_ARGUMENT;
  uint8_t gray[64];
  uint8_t *full_gray = malloc(ctx->width * ctx->height);
  if (!full_gray)
    return PH_ERR_ALLOCATION_FAILED;

  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
  ph_resize_grayscale(full_gray, ctx->width, ctx->height, gray, 8, 8);
  free(full_gray);

  uint64_t avg = 0;
  for (int i = 0; i < 64; i++)
    avg += gray[i];
  avg /= 64;

  uint64_t hash = 0;
  for (int i = 0; i < 64; i++) {
    if (gray[i] >= avg)
      hash |= (1ULL << i);
  }
  *out_hash = hash;
  return PH_SUCCESS;
}
</file>

<file path="src/hashes/bmh.c">
#include "../internal.h"
#include <stdlib.h>
#include <string.h>

PH_API ph_error_t ph_digest_create(size_t bits, ph_digest_t **out_digest) {
  if (!out_digest || bits == 0) {
    return PH_ERR_INVALID_ARGUMENT;
  }

  ph_digest_t *d = malloc(sizeof(ph_digest_t));
  if (!d) {
    return PH_ERR_ALLOCATION_FAILED;
  }

  /* Calculate byte size rounded up to the nearest byte */
  size_t byte_size = (bits + 7) / 8;
  d->data = calloc(1, byte_size);
  if (!d->data) {
    free(d);
    return PH_ERR_ALLOCATION_FAILED;
  }

  d->bits = bits;
  *out_digest = d;
  return PH_SUCCESS;
}

PH_API void ph_digest_free(ph_digest_t *digest) {
  if (digest) {
    free(digest->data);
    free(digest);
  }
}

PH_API ph_error_t ph_compute_bmh(ph_context_t *ctx, ph_digest_t *out_digest) {
  if (!ctx || !ctx->is_loaded || !out_digest || out_digest->bits != 256) {
    return PH_ERR_INVALID_ARGUMENT;
  }

  /* BMH for 256 bits requires a 16x16 pixel grid */
  uint8_t pixels[256];
  uint8_t *full_gray = malloc(ctx->width * ctx->height);
  if (!full_gray) {
    return PH_ERR_ALLOCATION_FAILED;
  }

  /* Step 1: Pre-process image to grayscale and resize to 16x16 */
  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
  ph_resize_grayscale(full_gray, ctx->width, ctx->height, pixels, 16, 16);
  free(full_gray);

  /* Step 2: Calculate the average pixel intensity */
  uint64_t total_sum = 0;
  for (int i = 0; i < 256; i++) {
    total_sum += pixels[i];
  }
  uint8_t avg = (uint8_t)(total_sum / 256);

  /* Step 3: Threshold pixels against the average and pack into the digest */
  for (int i = 0; i < 256; i++) {
    if (pixels[i] >= avg) {
      out_digest->data[i / 8] |= (1 << (i % 8));
    }
  }

  return PH_SUCCESS;
}
</file>

<file path="src/hashes/color_hash.c">
#include "../internal.h"
#include <math.h>
#include <stdlib.h>

PH_API ph_error_t ph_compute_color_hash(ph_context_t *ctx,
                                        ph_digest_t *out_digest) {
  if (!ctx || !ctx->is_loaded || !out_digest || out_digest->bits < 72) {
    return PH_ERR_INVALID_ARGUMENT;
  }

  /* * We calculate 3 color moments for 3 channels (R, G, B) = 9 values total.
   * Each value is stored as 1 byte (8 bits * 9 = 72 bits minimum required).
   */
  double mean[3] = {0}, std_dev[3] = {0}, skew[3] = {0};
  int num_pixels = ctx->width * ctx->height;

  /* Step 1: Calculate the Arithmetic Mean */
  for (int i = 0; i < num_pixels; i++) {
    for (int c = 0; c < 3; c++) {
      mean[c] += ctx->data[i * ctx->channels + c];
    }
  }
  for (int c = 0; c < 3; c++) {
    mean[c] /= num_pixels;
  }

  /* Step 2: Calculate Standard Deviation (2nd moment) and Skewness (3rd moment)
   */
  for (int i = 0; i < num_pixels; i++) {
    for (int c = 0; c < 3; c++) {
      double diff = ctx->data[i * ctx->channels + c] - mean[c];
      std_dev[c] += diff * diff;
      skew[c] += diff * diff * diff;
    }
  }

  for (int c = 0; c < 3; c++) {
    /* Standard deviation normalization */
    std_dev[c] = sqrt(std_dev[c] / num_pixels);

    /* Cube root for skewness normalization */
    skew[c] = cbrt(skew[c] / num_pixels);

    /* * Step 3: Write to digest.
     * Moments are mapped to 0-255 range and stored as bytes.
     */
    out_digest->data[c * 3 + 0] = (uint8_t)mean[c];
    out_digest->data[c * 3 + 1] = (uint8_t)fmin(255.0, std_dev[c]);
    out_digest->data[c * 3 + 2] = (uint8_t)fmin(255.0, fabs(skew[c]));
  }

  return PH_SUCCESS;
}
</file>

<file path="src/hashes/dhash.c">
#include "../internal.h"
#include <stdlib.h>

PH_API ph_error_t ph_compute_dhash(ph_context_t *ctx, uint64_t *out_hash) {
  if (!ctx || !ctx->is_loaded || !out_hash)
    return PH_ERR_INVALID_ARGUMENT;
  uint8_t gray[72]; // 9x8
  uint8_t *full_gray = malloc(ctx->width * ctx->height);
  if (!full_gray)
    return PH_ERR_ALLOCATION_FAILED;

  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
  ph_resize_grayscale(full_gray, ctx->width, ctx->height, gray, 9, 8);
  free(full_gray);

  uint64_t hash = 0;
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 8; col++) {
      if (gray[row * 9 + col] < gray[row * 9 + col + 1])
        hash |= (1ULL << (row * 8 + col));
    }
  }
  *out_hash = hash;
  return PH_SUCCESS;
}
</file>

<file path="src/hashes/phash.c">
#include "../internal.h"
#include <math.h>
#include <stdlib.h>

static void ph_dct_1d(const double *src, double *dst, int size) {
  for (int i = 0; i < size; i++) {
    double sum = 0;
    for (int j = 0; j < size; j++)
      sum += src[j] * cos(M_PI * i * (j + 0.5) / size);
    dst[i] = sum * ((i == 0) ? sqrt(1.0 / size) : sqrt(2.0 / size));
  }
}

PH_API ph_error_t ph_compute_phash(ph_context_t *ctx, uint64_t *out_hash) {
  if (!ctx || !ctx->is_loaded || !out_hash)
    return PH_ERR_INVALID_ARGUMENT;
  uint8_t gray32[1024];
  uint8_t *full_gray = malloc(ctx->width * ctx->height);
  if (!full_gray)
    return PH_ERR_ALLOCATION_FAILED;

  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
  ph_resize_grayscale(full_gray, ctx->width, ctx->height, gray32, 32, 32);
  free(full_gray);

  double dct_in[1024], dct_out[1024], temp[1024];
  for (int i = 0; i < 1024; i++)
    dct_in[i] = (double)gray32[i];

  // 2D DCT
  for (int i = 0; i < 32; i++)
    ph_dct_1d(&dct_in[i * 32], &temp[i * 32], 32);
  for (int j = 0; j < 32; j++) {
    double col_in[32], col_out[32];
    for (int i = 0; i < 32; i++)
      col_in[i] = temp[i * 32 + j];
    ph_dct_1d(col_in, col_out, 32);
    for (int i = 0; i < 32; i++)
      dct_out[i * 32 + j] = col_out[i];
  }

  double sum = 0;
  for (int i = 0; i < 8; i++)
    for (int j = 0; j < 8; j++)
      if (i != 0 || j != 0)
        sum += dct_out[i * 32 + j];

  double avg = sum / 63.0;
  uint64_t hash = 0;
  for (int i = 0; i < 8; i++)
    for (int j = 0; j < 8; j++)
      if (dct_out[i * 32 + j] > avg)
        hash |= (1ULL << (i * 8 + j));

  *out_hash = hash;
  return PH_SUCCESS;
}
</file>

<file path="src/hashes/radial.c">
#include "../internal.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>

#define RADIAL_PROJECTIONS 40
#define SAMPLES_PER_LINE 128 /* Increased for better precision */

/**
 * Helper: Bilinear Interpolation
 */
static double get_pixel_bilinear(const uint8_t *img, int w, int h, double x,
                                 double y) {
  if (x < 0 || x >= w - 1 || y < 0 || y >= h - 1)
    return 0.0;

  int x1 = (int)x;
  int y1 = (int)y;
  int x2 = x1 + 1;
  int y2 = y1 + 1;

  double dx = x - x1;
  double dy = y - y1;

  double p1 = img[y1 * w + x1];
  double p2 = img[y1 * w + x2];
  double p3 = img[y2 * w + x1];
  double p4 = img[y2 * w + x2];

  return p1 * (1.0 - dx) * (1.0 - dy) + p2 * dx * (1.0 - dy) +
         p3 * (1.0 - dx) * dy + p4 * dx * dy;
}

PH_API ph_error_t ph_compute_radial_hash(ph_context_t *ctx,
                                         ph_digest_t *out_digest) {
  if (!ctx || !ctx->is_loaded || !out_digest || out_digest->bits < 320)
    return PH_ERR_INVALID_ARGUMENT;

  size_t img_size = ctx->width * ctx->height;
  uint8_t *gray = malloc(img_size);
  uint8_t *blurred = malloc(img_size);

  if (!gray || !blurred) {
    free(gray);
    free(blurred);
    return PH_ERR_ALLOCATION_FAILED;
  }

  /* 1. Preprocessing Pipeline (as per Algorithm) */
  /* Convert to Grayscale */
  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, gray);

  /* Apply Gaussian Blur (Noise suppression) */
  ph_apply_gaussian_blur(gray, ctx->width, ctx->height, blurred);

  /* Apply Gamma Correction (Lighting normalization) */
  ph_apply_gamma(blurred, ctx->width, ctx->height);

  /* 2. Compute Radial Variance */
  double centerX = ctx->width / 2.0;
  double centerY = ctx->height / 2.0;
  double min_side = (ctx->width < ctx->height) ? ctx->width : ctx->height;
  double maxRadius = min_side / 2.0; /* Full radius */

  double variances[RADIAL_PROJECTIONS];
  double max_var = 0.0;

  /*
   * Scan 0 to 180 degrees (PI).
   * The Radon transform is symmetric, so 0-180 covers all unique line
   * orientations.
   */
  for (int i = 0; i < RADIAL_PROJECTIONS; i++) {
    double theta = (i * M_PI) / RADIAL_PROJECTIONS;
    double cos_t = cos(theta);
    double sin_t = sin(theta);

    double sum = 0.0;
    double sumSq = 0.0;
    int count = 0;

    /* Integrate along the full line (Diameter), from -R to +R */
    for (int r = -SAMPLES_PER_LINE / 2; r < SAMPLES_PER_LINE / 2; r++) {
      double dist = (r * maxRadius) / (SAMPLES_PER_LINE / 2.0);

      double px = centerX + dist * cos_t;
      double py = centerY + dist * sin_t;

      double val = get_pixel_bilinear(blurred, ctx->width, ctx->height, px, py);

      /* Only count pixels strictly inside the image circle */
      if (val > 0.0) {
        sum += val;
        sumSq += val * val;
        count++;
      }
    }

    if (count > 0) {
      double mean = sum / count;
      variances[i] = (sumSq / count) - (mean * mean);
    } else {
      variances[i] = 0.0;
    }

    if (variances[i] > max_var)
      max_var = variances[i];
  }

  /* 3. Normalize and Pack */
  /* We map the variance (0..max_var) to (0..255) */
  for (int i = 0; i < RADIAL_PROJECTIONS; i++) {
    if (max_var > 0.001) {
      /* Sqrt helps to compress the dynamic range of variance */
      out_digest->data[i] = (uint8_t)(sqrt(variances[i] / max_var) * 255.0);
    } else {
      out_digest->data[i] = 0;
    }
  }

  free(gray);
  free(blurred);
  return PH_SUCCESS;
}
</file>

<file path="src/hashes/whash.c">
#include "../internal.h"
#include <stdlib.h>

static void haar_1d(double *data, int n) {
  double temp[64];
  int h = n / 2;
  for (int i = 0; i < h; i++) {
    temp[i] = (data[2 * i] + data[2 * i + 1]) / 1.4142;
    temp[i + h] = (data[2 * i] - data[2 * i + 1]) / 1.4142;
  }
  for (int i = 0; i < n; i++)
    data[i] = temp[i];
}

PH_API ph_error_t ph_compute_whash(ph_context_t *ctx, uint64_t *out_hash) {
  if (!ctx || !ctx->is_loaded || !out_hash)
    return PH_ERR_INVALID_ARGUMENT;
  uint8_t gray[64];
  uint8_t *full_gray = malloc(ctx->width * ctx->height);
  if (!full_gray)
    return PH_ERR_ALLOCATION_FAILED;

  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
  ph_resize_grayscale(full_gray, ctx->width, ctx->height, gray, 8, 8);
  free(full_gray);

  double d[64];
  for (int i = 0; i < 64; i++)
    d[i] = gray[i];

  for (int i = 0; i < 8; i++)
    haar_1d(&d[i * 8], 8);
  for (int j = 0; j < 8; j++) {
    double col[8];
    for (int i = 0; i < 8; i++)
      col[i] = d[i * 8 + j];
    haar_1d(col, 8);
    for (int i = 0; i < 8; i++)
      d[i * 8 + j] = col[i];
  }

  double sum = 0;
  for (int i = 0; i < 64; i++)
    sum += d[i];
  double avg = sum / 64.0;

  uint64_t hash = 0;
  for (int i = 0; i < 64; i++)
    if (d[i] > avg)
      hash |= (1ULL << i);
  *out_hash = hash;
  return PH_SUCCESS;
}
</file>

<file path="src/core.c">
#include "internal.h"
#include <stdlib.h>

#define STB_IMAGE_IMPLEMENTATION
#include "../vendor/stb_image.h"

PH_API ph_error_t ph_create(ph_context_t **out_ctx) {
  if (!out_ctx)
    return PH_ERR_INVALID_ARGUMENT;
  ph_context_t *ctx = (ph_context_t *)calloc(1, sizeof(ph_context_t));
  if (!ctx)
    return PH_ERR_ALLOCATION_FAILED;
  *out_ctx = ctx;
  return PH_SUCCESS;
}

PH_API void ph_free(ph_context_t *ctx) {
  if (ctx) {
    if (ctx->data)
      stbi_image_free(ctx->data);
    free(ctx);
  }
}

PH_API ph_error_t ph_load_from_file(ph_context_t *ctx, const char *filepath) {
  if (!ctx || !filepath)
    return PH_ERR_INVALID_ARGUMENT;
  if (ctx->data)
    stbi_image_free(ctx->data);
  ctx->data = stbi_load(filepath, &ctx->width, &ctx->height, &ctx->channels, 0);
  if (!ctx->data)
    return PH_ERR_DECODE_FAILED;
  ctx->is_loaded = 1;
  return PH_SUCCESS;
}

PH_API ph_error_t ph_load_from_memory(ph_context_t *ctx, const uint8_t *buffer,
                                      size_t length) {
  if (!ctx || !buffer || length == 0)
    return PH_ERR_INVALID_ARGUMENT;
  if (ctx->data)
    stbi_image_free(ctx->data);
  ctx->data = stbi_load_from_memory(buffer, (int)length, &ctx->width,
                                    &ctx->height, &ctx->channels, 0);
  if (!ctx->data)
    return PH_ERR_DECODE_FAILED;
  ctx->is_loaded = 1;
  return PH_SUCCESS;
}
</file>

<file path="tests/test_bmh.c">
#include "libphash.h"
#include "test_macros.h"
#include <stdio.h>
#include <stdlib.h>

void test_bmh_logic() {
  ph_context_t *ctx1 = NULL;
  ph_context_t *ctx2 = NULL;
  ph_digest_t *digest1 = NULL;
  ph_digest_t *digest2 = NULL;

  ASSERT_OK(ph_create(&ctx1));
  ASSERT_OK(ph_create(&ctx2));

  /* Create 256-bit digests for BMH (Block Mean Hash) */
  ASSERT_OK(ph_digest_create(256, &digest1));
  ASSERT_OK(ph_digest_create(256, &digest2));

  ASSERT_OK(ph_load_from_file(ctx1, "tests/photo.jpeg"));
  ASSERT_OK(ph_load_from_file(ctx2, "tests/photo_copy.jpeg"));

  ASSERT_OK(ph_compute_bmh(ctx1, digest1));
  ASSERT_OK(ph_compute_bmh(ctx2, digest2));

  int dist = ph_hamming_distance_digest(digest1, digest2);
  printf("[BMH] Distance: %d bits\n", dist);

  /* For identical/copied images, distance should be very low.
     Threshold for 256-bit is typically higher than for 64-bit. */
  if (dist > 20) {
    fprintf(stderr, "BMH distance too high: %d\n", dist);
    exit(1);
  }

  ph_digest_free(digest1);
  ph_digest_free(digest2);
  ph_free(ctx1);
  ph_free(ctx2);

  printf("test_bmh_logic: PASSED\n");
}

int main() {
  test_bmh_logic();
  return 0;
}
</file>

<file path="tests/test_color.c">
#include "libphash.h"
#include "test_macros.h"
#include <stdio.h>

void test_color_difference() {
  ph_context_t *ctx_orig = NULL;
  ph_context_t *ctx_color = NULL;
  ph_digest_t *digest_orig = NULL;
  ph_digest_t *digest_color = NULL;
  uint64_t phash_orig, phash_color;

  ASSERT_OK(ph_create(&ctx_orig));
  ASSERT_OK(ph_create(&ctx_color));
  ASSERT_OK(ph_digest_create(72, &digest_orig));
  ASSERT_OK(ph_digest_create(72, &digest_color));

  /* 1. Load original and color-shifted images */
  ASSERT_OK(ph_load_from_file(ctx_orig, "tests/photo.jpeg"));
  ASSERT_OK(ph_load_from_file(ctx_color, "tests/photo_color_changed.jpeg"));

  /* 2. Compute pHash (Structural) */
  ASSERT_OK(ph_compute_phash(ctx_orig, &phash_orig));
  ASSERT_OK(ph_compute_phash(ctx_color, &phash_color));

  /* 3. Compute Color Moment Hash (Color distribution) */
  ASSERT_OK(ph_compute_color_hash(ctx_orig, digest_orig));
  ASSERT_OK(ph_compute_color_hash(ctx_color, digest_color));

  /* 4. Compare results */
  int p_dist = ph_hamming_distance(phash_orig, phash_color);
  double c_dist = ph_l2_distance(digest_orig, digest_color);

  printf("[pHash] Structural distance: %d bits\n", p_dist);
  printf("[ColorHash] L2 Color distance: %.2f\n", c_dist);

  /* * In this scenario, pHash distance should be low (same shapes),
   * but ColorHash distance should be significant (different colors).
   */
  if (p_dist < 5 && c_dist > 10.0) {
    printf("Test Logic: Images are structurally similar but color-distinct. "
           "SUCCESS.\n");
  }

  /* Cleanup */
  ph_digest_free(digest_orig);
  ph_digest_free(digest_color);
  ph_free(ctx_orig);
  ph_free(ctx_color);
}

int main() {
  test_color_difference();
  return 0;
}
</file>

<file path="tests/test_core.c">
#include "libphash.h"
#include "test_macros.h"

void test_lifecycle() {
  ph_context_t *ctx = NULL;
  ASSERT_OK(ph_create(&ctx));
  if (!ctx)
    exit(1);
  ph_free(ctx);
  printf("test_lifecycle: PASSED\n");
}

int main() {
  test_lifecycle();
  return 0;
}
</file>

<file path="tests/test_hashes.c">
#include "libphash.h"
#include "test_macros.h"

void test_hamming() {
  uint64_t h1 = 0x0000000000000000ULL;
  uint64_t h2 = 0x000000000000000FULL; // 4 bits set
  ASSERT_INT_EQ(4, ph_hamming_distance(h1, h2));
  printf("test_hamming: PASSED\n");
}

int main() {
  test_hamming();
  return 0;
}
</file>

<file path="tests/test_image_hashes.c">
#include "libphash.h"
#include "test_macros.h"
#include <stdio.h>

void test_hash_algorithm(const char *name,
                         ph_error_t (*hash_func)(ph_context_t *, uint64_t *)) {
  ph_context_t *ctx1 = NULL;
  ph_context_t *ctx2 = NULL;
  uint64_t hash1 = 0, hash2 = 0;

  ASSERT_OK(ph_create(&ctx1));
  ASSERT_OK(ph_create(&ctx2));

  ASSERT_OK(ph_load_from_file(ctx1, "tests/photo.jpeg"));
  ASSERT_OK(ph_load_from_file(ctx2, "tests/photo_copy.jpeg"));

  ASSERT_OK(hash_func(ctx1, &hash1));
  ASSERT_OK(hash_func(ctx2, &hash2));

  int distance = ph_hamming_distance(hash1, hash2);

  printf("[%s] Hash1: %llu, Hash2: %llu, Distance: %d\n", name,
         (unsigned long long)hash1, (unsigned long long)hash2, distance);

  if (distance > 10) {
    fprintf(stderr, "[FAIL] %s: Images are too different (distance %d)\n", name,
            distance);
    exit(1);
  }

  ph_free(ctx1);
  ph_free(ctx2);
  printf("test_%s: PASSED\n", name);
}

int main() {
  test_hash_algorithm("aHash", ph_compute_ahash);
  test_hash_algorithm("dHash", ph_compute_dhash);
  test_hash_algorithm("pHash", ph_compute_phash);
  return 0;
}
</file>

<file path="tests/test_internal.c">
#include "../src/internal.h"
#include "test_macros.h"
#include <stdint.h>
#include <string.h>

/* Test grayscale conversion math */
void test_grayscale_conversion() {
  // RGB: 255, 0, 0 (Red) -> Luminance ~76
  // RGB: 0, 255, 0 (Green) -> Luminance ~149
  uint8_t rgb[] = {255, 0, 0, 0, 255, 0};
  uint8_t gray[2];

  ph_to_grayscale(rgb, 2, 1, 3, gray);

  if (gray[0] == 0 || gray[1] == 0) {
    fprintf(stderr, "Grayscale conversion produced black pixels\n");
    exit(1);
  }
  printf("test_grayscale_conversion: PASSED\n");
}

/* Test resizing logic (Downsampling) */
void test_image_resizing() {
  uint8_t src[16] = {255, 255, 0,   0,   255, 255, 0,   0,
                     0,   0,   255, 255, 0,   0,   255, 255};
  uint8_t dst[4]; // Resize 4x4 to 2x2

  ph_resize_grayscale(src, 4, 4, dst, 2, 2);

  // Top-left quadrant of src is all 255, so dst[0] should be 255
  ASSERT_INT_EQ(255, dst[0]);
  // Top-right quadrant is 0
  ASSERT_INT_EQ(0, dst[1]);

  printf("test_image_resizing: PASSED\n");
}

/* Test Hamming Distance for Digests (Large Hashes) */
void test_digest_hamming() {
  ph_digest_t *d1, *d2;
  ph_digest_create(256, &d1);
  ph_digest_create(256, &d2);

  memset(d1->data, 0, 32);
  memset(d2->data, 0, 32);

  d1->data[0] = 0x01; // 1 bit set
  d2->data[0] = 0x03; // 2 bits set (1 overlapping)

  // Distance between 00000001 and 00000011 is 1 bit
  ASSERT_INT_EQ(1, ph_hamming_distance_digest(d1, d2));

  ph_digest_free(d1);
  ph_digest_free(d2);
  printf("test_digest_hamming: PASSED\n");
}

int main() {
  test_grayscale_conversion();
  test_image_resizing();
  test_digest_hamming();
  return 0;
}
</file>

<file path="tests/test_radial.c">
#include "libphash.h"
#include "test_macros.h"
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/**
 * @brief FFI/Logic Utility:
 * When an image is rotated, the radial variance array shifts cyclically.
 * Since we scan 0..180 degrees, a 90 degree rotation is a shift of N/2.
 */
double calculate_rotated_l2(const ph_digest_t *a, const ph_digest_t *b) {
  if (a->bits != b->bits) {
    return -1.0;
  }

  int n = (int)(a->bits / 8); /* 40 bytes */
  double min_l2 = DBL_MAX;

  /* Try all possible cyclic shifts */
  for (int shift = 0; shift < n; shift++) {
    double current_sum_sq = 0;
    for (int i = 0; i < n; i++) {
      int b_idx = (i + shift) % n;
      double diff = (double)a->data[i] - (double)b->data[b_idx];
      current_sum_sq += diff * diff;
    }

    double current_l2 = sqrt(current_sum_sq);
    if (current_l2 < min_l2) {
      min_l2 = current_l2;
    }
  }

  return min_l2;
}

void test_radial_with_real_rotation() {
  ph_context_t *ctx_orig = NULL;
  ph_context_t *ctx_rot = NULL;
  ph_digest_t *dig_orig = NULL;
  ph_digest_t *dig_rot = NULL;

  /* 1. Initialization */
  ASSERT_OK(ph_create(&ctx_orig));
  ASSERT_OK(ph_create(&ctx_rot));
  ASSERT_OK(ph_digest_create(320, &dig_orig));
  ASSERT_OK(ph_digest_create(320, &dig_rot));

  /* 2. Load Image Files */
  ph_error_t err1 = ph_load_from_file(ctx_orig, "tests/photo.jpeg");
  ph_error_t err2 = ph_load_from_file(ctx_rot, "tests/photo_rotated_90.jpeg");

  if (err1 != PH_SUCCESS || err2 != PH_SUCCESS) {
    fprintf(stderr, "Skip test: Could not find images.\n");
    goto cleanup;
  }

  /* 3. Compute Radial Variance Hash */
  ASSERT_OK(ph_compute_radial_hash(ctx_orig, dig_orig));
  ASSERT_OK(ph_compute_radial_hash(ctx_rot, dig_rot));

  /* 4. Comparison */
  double direct_dist = ph_l2_distance(dig_orig, dig_rot);
  double rotated_dist = calculate_rotated_l2(dig_orig, dig_rot);

  printf("[Radial] Direct L2 Distance: %.2f\n", direct_dist);
  printf("[Radial] Min L2 Distance (Rotation Corrected): %.2f\n", rotated_dist);

  /*
   * With Gaussian Blur and Gamma, the hash is more stable.
   * A match should be very close to 0 (typically < 10.0).
   */
  if (rotated_dist > 25.0) {
    fprintf(stderr,
            "FAIL: Radial hash distance too high for rotated image: %.2f\n",
            rotated_dist);
    exit(1);
  }

  if (rotated_dist >= direct_dist && direct_dist > 1.0) {
    fprintf(stderr, "FAIL: Rotation search did not improve distance\n");
    exit(1);
  }

  printf("test_radial_with_real_rotation: PASSED\n");

cleanup:
  ph_digest_free(dig_orig);
  ph_digest_free(dig_rot);
  ph_free(ctx_orig);
  ph_free(ctx_rot);
}

int main() {
  test_radial_with_real_rotation();
  return 0;
}
</file>

<file path=".gitignore">
# Object files and libraries
*.o
*.a
*.so
*.dylib
*.dll
obj/

# Executables (Tests)
test_*
!tests/test_*.c

# IDEs and Editors
.vscode/
.idea/
*.swp
*.swo
.DS_Store

# Build artifacts
dist/
build/

# Test images (if generated)
tests/output_*.jpeg
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2026 gudoshnikovn

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# libphash

A high-performance, portable C library for Perceptual Hashing. Designed for image similarity detection with zero external dependencies (except for the included `stb_image`).

## Features

- **Multiple Algorithms**:
  - `aHash` (Average Hash): Fast, based on average intensity.
  - `dHash` (Difference Hash): Fast, resistant to aspect ratio changes.
  - `pHash` (Perceptual Hash): Robust, uses Discrete Cosine Transform (DCT).
- **FFI-Friendly**: Clean C API with opaque pointers, making it easy to wrap in Python (ctypes/cffi), Rust, or Node.js.
- **Thread-Safe**: No global state.
- **Cross-Platform**: Compatible with GCC, Clang, and MSVC.

## Architecture

The library follows a strict separation between public API and internal implementation:
- `include/libphash.h`: Public interface and error codes.
- `src/internal.h`: Internal structures and image processing helpers.
- `src/hashes/`: Core hash algorithm implementations.

## Building

To build the static library and run tests, you only need `make` and a C compiler:

```bash
# Build the library (libphash.a)
make

# Run all tests
make test

# Clean build artifacts
make clean
```

## Usage Example (C)

```c
#include <libphash.h>
#include <stdio.h>

int main() {
    ph_context_t *ctx = NULL;
    uint64_t hash1, hash2;

    ph_create(&ctx);
    
    ph_load_from_file(ctx, "image1.jpg");
    ph_compute_phash(ctx, &hash1);
    
    ph_load_from_file(ctx, "image2.jpg");
    ph_compute_phash(ctx, &hash2);

    int distance = ph_hamming_distance(hash1, hash2);
    printf("Hamming Distance: %d\n", distance);

    if (distance < 5) {
        printf("Images are very similar!\n");
    }

    ph_free(ctx);
    return 0;
}
```

## FFI Integration Notes

- **Opaque Pointer**: `ph_context_t` is an opaque struct. In high-level languages, treat it as a `void*` or `uintptr_t`.
- **Memory Management**: Always call `ph_free()` to release image data and context memory allocated on the C heap.
- **Error Handling**: Functions return `ph_error_t` (int). `0` always indicates `PH_SUCCESS`.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
Includes `stb_image` by Sean Barrett (Public Domain/MIT).
</file>

<file path="src/image.c">
#include "internal.h"
#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

void ph_to_grayscale(const uint8_t *src, int w, int h, int channels,
                     uint8_t *dst) {
  for (int i = 0; i < w * h; i++) {
    uint8_t r = src[i * channels];
    uint8_t g = src[i * channels + 1];
    uint8_t b = src[i * channels + 2];
    /* Standard luminance formula */
    dst[i] = (uint8_t)((77 * r + 150 * g + 29 * b) >> 8);
  }
}

void ph_resize_grayscale(const uint8_t *src, int sw, int sh, uint8_t *dst,
                         int dw, int dh) {
  double x_ratio = (double)sw / dw;
  double y_ratio = (double)sh / dh;
  for (int dy = 0; dy < dh; dy++) {
    for (int dx = 0; dx < dw; dx++) {
      int sx_start = (int)(dx * x_ratio), sy_start = (int)(dy * y_ratio);
      int sx_end = (int)((dx + 1) * x_ratio),
          sy_end = (int)((dy + 1) * y_ratio);
      uint32_t sum = 0;
      int count = 0;
      for (int y = sy_start; y < sy_end && y < sh; y++) {
        for (int x = sx_start; x < sx_end && x < sw; x++) {
          sum += src[y * sw + x];
          count++;
        }
      }
      dst[dy * dw + dx] = (count > 0) ? (uint8_t)(sum / count) : 0;
    }
  }
}

void ph_apply_gaussian_blur(const uint8_t *src, int w, int h, uint8_t *dst) {
  /* 3x3 Gaussian Kernel approximation
     1 2 1
     2 4 2
     1 2 1
     Divisor: 16
  */
  int kernel[3][3] = {{1, 2, 1}, {2, 4, 2}, {1, 2, 1}};

  /* Copy borders to avoid boundary checks in the loop */
  memcpy(dst, src, w * h);

  for (int y = 1; y < h - 1; y++) {
    for (int x = 1; x < w - 1; x++) {
      int sum = 0;
      for (int ky = -1; ky <= 1; ky++) {
        for (int kx = -1; kx <= 1; kx++) {
          int px = src[(y + ky) * w + (x + kx)];
          sum += px * kernel[ky + 1][kx + 1];
        }
      }
      dst[y * w + x] = (uint8_t)(sum >> 4); /* Divide by 16 */
    }
  }
}

void ph_apply_gamma(uint8_t *data, int w, int h) {
  /* Precompute Gamma LUT (Gamma 2.2) */
  static uint8_t lut[256];
  static int lut_init = 0;

  if (!lut_init) {
    for (int i = 0; i < 256; i++) {
      lut[i] = (uint8_t)(pow(i / 255.0, 1.0 / 2.2) * 255.0);
    }
    lut_init = 1;
  }

  for (int i = 0; i < w * h; i++) {
    data[i] = lut[data[i]];
  }
}
</file>

<file path="src/internal.h">
#ifndef INTERNAL_H
#define INTERNAL_H

#include "../include/libphash.h"
#include <stdint.h>

/*
 * Internal Image Processing Helpers
 */

/* Converts RGB/RGBA to Grayscale */
void ph_to_grayscale(const uint8_t *src, int w, int h, int channels,
                     uint8_t *dst);

/* Resizes a grayscale image */
void ph_resize_grayscale(const uint8_t *src, int sw, int sh, uint8_t *dst,
                         int dw, int dh);

/*
 * New Helpers for Radial Hash
 */

/* Applies a 3x3 Gaussian Blur to reduce noise */
void ph_apply_gaussian_blur(const uint8_t *src, int w, int h, uint8_t *dst);

/* Applies Gamma Correction (gamma=2.2) to normalize brightness */
void ph_apply_gamma(uint8_t *data, int w, int h);

/* Internal Context Structure */
struct ph_context {
  uint8_t *data; /* Raw image data (stb_image) */
  int width;
  int height;
  int channels;
  int is_loaded;
};

#endif /* INTERNAL_H */
</file>

<file path="src/hashes/common.c">
#include "../internal.h"
#include <math.h>
#include <stdint.h>

#if defined(__ARM_NEON) || defined(__ARM_NEON__)
#include <arm_neon.h>
#elif defined(__SSE4_2__)
#include <nmmintrin.h>
#endif

PH_API const char *ph_version(void) { return "1.2.0"; }

PH_API int ph_hamming_distance(uint64_t hash1, uint64_t hash2) {
  uint64_t x = hash1 ^ hash2;
#if defined(__GNUC__) || defined(__clang__)
  return __builtin_popcountll(x);
#elif defined(_MSC_VER)
  return (int)__popcnt64(x);
#else
  int count = 0;
  while (x) {
    x &= (x - 1);
    count++;
  }
  return count;
#endif
}

PH_API int ph_hamming_distance_digest(const ph_digest_t *a,
                                      const ph_digest_t *b) {
  if (!a || !b || a->bits != b->bits)
    return -1;
  size_t len = (a->bits + 7) / 8;
  int total = 0;
  size_t i = 0;

#if defined(__ARM_NEON) || defined(__ARM_NEON__)
  uint16x8_t v_sum = vdupq_n_u16(0);

  for (; i + 16 <= len; i += 16) {
    uint8x16_t va = vld1q_u8(&a->data[i]);
    uint8x16_t vb = vld1q_u8(&b->data[i]);
    uint8x16_t vxor = veorq_u8(va, vb);
    uint8x16_t vcnt = vcntq_u8(vxor);
    // Accumulate 8-bit counts into 16-bit lanes to prevent overflow
    v_sum = vpadalq_u8(v_sum, vcnt);
  }
  // vaddlvq_u16 sums all lanes in the vector into a single 64-bit value
  total = (int)vaddlvq_u16(v_sum);
#endif

  for (; i < len; i++) {
    uint8_t x = a->data[i] ^ b->data[i];
#ifdef __GNUC__
    total += __builtin_popcount(x);
#else
    while (x) {
      x &= (x - 1);
      total++;
    }
#endif
  }
  return total;
}
PH_API double ph_l2_distance(const ph_digest_t *a, const ph_digest_t *b) {
  if (!a || !b || a->bits != b->bits)
    return -1.0;

  double sum = 0;
  size_t byte_count = (a->bits + 7) / 8;
  for (size_t i = 0; i < byte_count; i++) {
    double diff = (double)a->data[i] - (double)b->data[i];
    sum += diff * diff;
  }
  return sqrt(sum);
}
</file>

<file path="Makefile">
CC = gcc
CFLAGS = -I./include -O3 -Wall -Wextra -fPIC
LDFLAGS = -lm

# Detect Architecture for SIMD
UNAME_M := $(shell uname -m)
ifeq ($(UNAME_M),x86_64)
    CFLAGS += -msse4.2
endif
ifeq ($(UNAME_M),arm64)
    CFLAGS += -march=armv8-a+simd
endif

LIB_NAME = libphash.a
OBJ_DIR = obj
SRC_DIR = src
HASH_DIR = $(SRC_DIR)/hashes
TEST_DIR = tests

SRCS = $(wildcard $(SRC_DIR)/*.c) $(wildcard $(HASH_DIR)/*.c)
OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

TEST_SRCS = $(wildcard $(TEST_DIR)/test_*.c)
TEST_BINS = $(TEST_SRCS:$(TEST_DIR)/%.c=%)

all: $(LIB_NAME) $(TEST_BINS)

# Debug target with AddressSanitizer
debug: CFLAGS = -I./include -g -O0 -fsanitize=address,undefined -Wall -Wextra -fPIC
debug: clean all

$(LIB_NAME): $(OBJS)
	ar rcs $@ $^

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

test_%: $(TEST_DIR)/test_%.c $(LIB_NAME)
	$(CC) $(CFLAGS) $< $(LIB_NAME) -o $@ $(LDFLAGS)

test: $(TEST_BINS)
	@for test in $(TEST_BINS); do ./$$test || exit 1; done
	@echo "ALL TESTS PASSED"

clean:
	rm -rf $(OBJ_DIR) *.a test_*
</file>

<file path="include/libphash.h">
#ifndef LIBPHASH_H
#define LIBPHASH_H

#include <stddef.h>
#include <stdint.h>

/*
 * Feature Detection for modern C attributes.
 * Supports C23 standard, with fallbacks for GCC, Clang, and MSVC.
 */
#ifndef PH_NODISCARD
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 202311L
/* C23 standard way */
#define PH_NODISCARD [[nodiscard]]
#elif defined(__GNUC__) || defined(__clang__)
/* GCC/Clang extension */
#define PH_NODISCARD __attribute__((warn_unused_result))
#elif defined(_MSC_VER) && _MSC_VER >= 1700
/* MSVC (Visual Studio) way */
#define PH_NODISCARD _Check_return_
#else
/* Fallback for older C standards (like C89/C99/C17) */
#define PH_NODISCARD
#endif
#endif

/*
 * Visibility macros for Shared Libraries (DLLs)
 */
#ifndef PH_API
#if defined(_WIN32) || defined(__CYGWIN__)
#ifdef LIBPHASH_EXPORTS
#define PH_API __declspec(dllexport)
#else
#define PH_API __declspec(dllimport)
#endif
#else
#if __GNUC__ >= 4
#define PH_API __attribute__((visibility("default")))
#else
#define PH_API
#endif
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Returns the library version string (e.g., "1.2.0").
 */
PH_API const char *ph_version(void);

/**
 * @section Types and Errors
 */

/**
 * @brief Error codes for libphash operations.
 */
typedef enum {
  PH_SUCCESS = 0,
  PH_ERR_ALLOCATION_FAILED = -1,
  PH_ERR_DECODE_FAILED = -2,
  PH_ERR_INVALID_ARGUMENT = -3,
  PH_ERR_NOT_IMPLEMENTED = -4,
} ph_error_t;

/**
 * @brief Opaque context handle holding image data.
 * In FFI (Python/Rust), this should be treated as an opaque pointer (void*).
 */
typedef struct ph_context ph_context_t;

/**
 * @brief Structure for arbitrary length hashes (e.g., 256-bit for BMH).
 * In FFI (Python/Rust), this is passed as a pointer to the structure.
 */
typedef struct {
  uint8_t *data;
  size_t bits;
} ph_digest_t;

/**
 * @section Context Management
 */

/**
 * @brief Creates a new phash context.
 * @param out_ctx Pointer to the context handle to be initialized.
 * @return PH_SUCCESS on success.
 */
PH_API PH_NODISCARD ph_error_t ph_create(ph_context_t **out_ctx);

/**
 * @brief Frees the context and associated image data.
 * @param ctx Context handle. Safe to pass NULL.
 */
PH_API void ph_free(ph_context_t *ctx);

/**
 * @brief Loads an image from a file path.
 * @param ctx Valid context handle.
 * @param filepath Path to the image file (UTF-8).
 * @return PH_SUCCESS on success.
 */
PH_API PH_NODISCARD ph_error_t ph_load_from_file(ph_context_t *ctx,
                                                 const char *filepath);

/**
 * @section Standard 64-bit Hashing
 * Best for general use cases and fast comparisons.
 */

/**
 * @brief Computes the Average Hash (aHash).
 * Fast, but sensitive to lighting changes.
 */
PH_API PH_NODISCARD ph_error_t ph_compute_ahash(ph_context_t *ctx,
                                                uint64_t *out_hash);

/**
 * @brief Computes the Difference Hash (dHash).
 * Very fast and resistant to aspect ratio changes.
 */
PH_API PH_NODISCARD ph_error_t ph_compute_dhash(ph_context_t *ctx,
                                                uint64_t *out_hash);

/**
 * @brief Computes the Perceptual Hash (pHash) using DCT.
 * Most robust, but computationally expensive.
 */
PH_API PH_NODISCARD ph_error_t ph_compute_phash(ph_context_t *ctx,
                                                uint64_t *out_hash);

/**
 * @brief Block Mean Hash (BMH).
 * Typically uses a 16x16 grid (256 bits).
 */
PH_API PH_NODISCARD ph_error_t ph_compute_bmh(ph_context_t *ctx,
                                              ph_digest_t *out_digest);

/**
 * @brief Computes Color Moment Hash.
 * Analyzes the distribution of color channels (R, G, B).
 * Useful for distinguishing images that appear identical in grayscale.
 */
PH_API PH_NODISCARD ph_error_t ph_compute_color_hash(ph_context_t *ctx,
                                                     ph_digest_t *out_digest);

/**
 * @brief Computes the Radial Variance Hash (RVH).
 * Resistant to rotation. Uses 40 projections (angles).
 * @param out_digest Should be initialized with 320 bits (40 bytes).
 */
PH_API PH_NODISCARD ph_error_t ph_compute_radial_hash(ph_context_t *ctx,
                                                      ph_digest_t *out_digest);

/**
 * @brief Computes the Wavelet Hash (wHash) using Haar Wavelets.
 * Excellent for local feature persistence.
 */
PH_API PH_NODISCARD ph_error_t ph_compute_whash(ph_context_t *ctx,
                                                uint64_t *out_hash);

/**
 * @brief Computes the Marr-Hildreth Hash (mHash).
 * Based on edge detection. Very resistant to brightness/contrast changes.
 */
PH_API PH_NODISCARD ph_error_t ph_compute_mhash(ph_context_t *ctx,
                                                uint64_t *out_hash);

/**
 * @brief Calculates the Hamming distance between two 64-bit hashes.
 * @return Number of differing bits (0-64). 0 means identical hashes.
 */
PH_API int ph_hamming_distance(uint64_t hash1, uint64_t hash2);

/**
 * @section Arbitrary Length Hashing (Digests)
 * Used for high-precision hashes that exceed 64 bits.
 */

/**
 * @brief Allocates and initializes a new digest structure.
 * @param bits Number of bits for the digest.
 * @param out_digest Pointer to the digest handle to be initialized.
 */
PH_API ph_error_t ph_digest_create(size_t bits, ph_digest_t **out_digest);

/**
 * @brief Frees the memory allocated for a digest.
 * @param digest Digest handle.
 */
PH_API void ph_digest_free(ph_digest_t *digest);

/**
 * @brief Calculates the Hamming distance between two arbitrary length digests.
 * @return Number of differing bits, or -1 if the digest lengths do not match.
 */
PH_API int ph_hamming_distance_digest(const ph_digest_t *a,
                                      const ph_digest_t *b);

/**
 * @brief Calculates the Euclidean distance (L2 norm) between digests.
 * Recommended for Color Moment Hash comparison.
 * @return The distance as a double, or -1.0 if digest lengths do not match.
 */
PH_API double ph_l2_distance(const ph_digest_t *a, const ph_digest_t *b);

#ifdef __cplusplus
}
#endif

#endif /* LIBPHASH_H */
</file>

</files>

<git_diffs>
<git_diff_work_tree>

</git_diff_work_tree>
<git_diff_staged>
diff --git a/Makefile b/Makefile
index 5801627..1bbe4f1 100644
--- a/Makefile
+++ b/Makefile
@@ -1,62 +1,47 @@
 CC = gcc
-# Added optimization flags and math support
 CFLAGS = -I./include -O3 -Wall -Wextra -fPIC
 LDFLAGS = -lm
 
+# Detect Architecture for SIMD
+UNAME_M := $(shell uname -m)
+ifeq ($(UNAME_M),x86_64)
+    CFLAGS += -msse4.2
+endif
+ifeq ($(UNAME_M),arm64)
+    CFLAGS += -march=armv8-a+simd
+endif
+
 LIB_NAME = libphash.a
 OBJ_DIR = obj
 SRC_DIR = src
 HASH_DIR = $(SRC_DIR)/hashes
 TEST_DIR = tests
 
-# Library source files (including new algorithms)
-SRCS = $(SRC_DIR)/core.c \
-       $(SRC_DIR)/image.c \
-       $(HASH_DIR)/ahash.c \
-       $(HASH_DIR)/dhash.c \
-       $(HASH_DIR)/phash.c \
-       $(HASH_DIR)/bmh.c \
-       $(HASH_DIR)/color_hash.c \
-       $(HASH_DIR)/radial.c \
-       $(HASH_DIR)/common.c
-
-# Map .c paths to .o paths
+SRCS = $(wildcard $(SRC_DIR)/*.c) $(wildcard $(HASH_DIR)/*.c)
 OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
 
-# Automatically find all test files
 TEST_SRCS = $(wildcard $(TEST_DIR)/test_*.c)
 TEST_BINS = $(TEST_SRCS:$(TEST_DIR)/%.c=%)
 
-.PHONY: all clean test
-
 all: $(LIB_NAME) $(TEST_BINS)
 
-# Build the static library
+# Debug target with AddressSanitizer
+debug: CFLAGS = -I./include -g -O0 -fsanitize=address,undefined -Wall -Wextra -fPIC
+debug: clean all
+
 $(LIB_NAME): $(OBJS)
-	@echo "Archiving $(LIB_NAME)..."
-	@ar rcs $@ $^
+	ar rcs $@ $^
 
-# Compile object files and recreate directory structure
 $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
 	@mkdir -p $(dir $@)
 	$(CC) $(CFLAGS) -c $< -o $@
 
-# Build test executables
-# Order is critical: test source -> static library -> linker flags
 test_%: $(TEST_DIR)/test_%.c $(LIB_NAME)
 	$(CC) $(CFLAGS) $< $(LIB_NAME) -o $@ $(LDFLAGS)
 
-# Execute all tests sequentially
 test: $(TEST_BINS)
-	@echo "Starting test execution..."
-	@for test in $(TEST_BINS); do \
-		echo "Running $$test..."; \
-		./$$test || exit 1; \
-	done
-	@echo "------------------------------"
-	@echo "ALL TESTS PASSED SUCCESSFULLY"
-
-# Remove build artifacts
+	@for test in $(TEST_BINS); do ./$$test || exit 1; done
+	@echo "ALL TESTS PASSED"
+
 clean:
 	rm -rf $(OBJ_DIR) *.a test_*
-	@echo "Cleaned up build artifacts."
diff --git a/include/libphash.h b/include/libphash.h
index f61c966..73205ec 100644
--- a/include/libphash.h
+++ b/include/libphash.h
@@ -47,6 +47,11 @@
 extern "C" {
 #endif
 
+/**
+ * @brief Returns the library version string (e.g., "1.2.0").
+ */
+PH_API const char *ph_version(void);
+
 /**
  * @section Types and Errors
  */
@@ -153,12 +158,19 @@ PH_API PH_NODISCARD ph_error_t ph_compute_radial_hash(ph_context_t *ctx,
                                                       ph_digest_t *out_digest);
 
 /**
- * @brief Computes the Wavelet Hash (wHash).
- * Uses Haar Wavelets. Very robust to local image modifications.
+ * @brief Computes the Wavelet Hash (wHash) using Haar Wavelets.
+ * Excellent for local feature persistence.
  */
 PH_API PH_NODISCARD ph_error_t ph_compute_whash(ph_context_t *ctx,
                                                 uint64_t *out_hash);
 
+/**
+ * @brief Computes the Marr-Hildreth Hash (mHash).
+ * Based on edge detection. Very resistant to brightness/contrast changes.
+ */
+PH_API PH_NODISCARD ph_error_t ph_compute_mhash(ph_context_t *ctx,
+                                                uint64_t *out_hash);
+
 /**
  * @brief Calculates the Hamming distance between two 64-bit hashes.
  * @return Number of differing bits (0-64). 0 means identical hashes.
diff --git a/src/hashes/common.c b/src/hashes/common.c
index bdf167c..11702d6 100644
--- a/src/hashes/common.c
+++ b/src/hashes/common.c
@@ -2,12 +2,20 @@
 #include <math.h>
 #include <stdint.h>
 
+#if defined(__ARM_NEON) || defined(__ARM_NEON__)
+#include <arm_neon.h>
+#elif defined(__SSE4_2__)
+#include <nmmintrin.h>
+#endif
+
+PH_API const char *ph_version(void) { return "1.2.0"; }
+
 PH_API int ph_hamming_distance(uint64_t hash1, uint64_t hash2) {
   uint64_t x = hash1 ^ hash2;
-#if defined(_MSC_VER)
-  return (int)__popcnt64(x);
-#elif defined(__GNUC__) || defined(__clang__)
+#if defined(__GNUC__) || defined(__clang__)
   return __builtin_popcountll(x);
+#elif defined(_MSC_VER)
+  return (int)__popcnt64(x);
 #else
   int count = 0;
   while (x) {
@@ -20,33 +28,40 @@ PH_API int ph_hamming_distance(uint64_t hash1, uint64_t hash2) {
 
 PH_API int ph_hamming_distance_digest(const ph_digest_t *a,
                                       const ph_digest_t *b) {
-  if (!a || !b || a->bits != b->bits) {
+  if (!a || !b || a->bits != b->bits)
     return -1;
-  }
+  size_t len = (a->bits + 7) / 8;
+  int total = 0;
+  size_t i = 0;
 
-  int total_distance = 0;
-  size_t byte_count = (a->bits + 7) / 8;
+#if defined(__ARM_NEON) || defined(__ARM_NEON__)
+  uint16x8_t v_sum = vdupq_n_u16(0);
 
-  for (size_t i = 0; i < byte_count; i++) {
-    uint8_t x = a->data[i] ^ b->data[i];
+  for (; i + 16 <= len; i += 16) {
+    uint8x16_t va = vld1q_u8(&a->data[i]);
+    uint8x16_t vb = vld1q_u8(&b->data[i]);
+    uint8x16_t vxor = veorq_u8(va, vb);
+    uint8x16_t vcnt = vcntq_u8(vxor);
+    // Accumulate 8-bit counts into 16-bit lanes to prevent overflow
+    v_sum = vpadalq_u8(v_sum, vcnt);
+  }
+  // vaddlvq_u16 sums all lanes in the vector into a single 64-bit value
+  total = (int)vaddlvq_u16(v_sum);
+#endif
 
-    /* Use CPU-optimized population count where available */
-#if defined(_MSC_VER)
-    total_distance += (int)__popcnt16((uint16_t)x);
-#elif defined(__GNUC__) || defined(__clang__)
-    total_distance += __builtin_popcount(x);
+  for (; i < len; i++) {
+    uint8_t x = a->data[i] ^ b->data[i];
+#ifdef __GNUC__
+    total += __builtin_popcount(x);
 #else
-    /* Fallback: Kernighan's bit counting algorithm */
     while (x) {
       x &= (x - 1);
-      total_distance++;
+      total++;
     }
 #endif
   }
-
-  return total_distance;
+  return total;
 }
-
 PH_API double ph_l2_distance(const ph_digest_t *a, const ph_digest_t *b) {
   if (!a || !b || a->bits != b->bits)
     return -1.0;
diff --git a/src/hashes/mhash.c b/src/hashes/mhash.c
new file mode 100644
index 0000000..101d571
--- /dev/null
+++ b/src/hashes/mhash.c
@@ -0,0 +1,33 @@
+#include "../internal.h"
+#include <stdlib.h>
+
+PH_API ph_error_t ph_compute_mhash(ph_context_t *ctx, uint64_t *out_hash) {
+  if (!ctx || !ctx->is_loaded || !out_hash)
+    return PH_ERR_INVALID_ARGUMENT;
+
+  // 1. Resize to 16x16 to capture structural edges
+  uint8_t tiny[256];
+  uint8_t *full_gray = malloc(ctx->width * ctx->height);
+  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
+  ph_resize_grayscale(full_gray, ctx->width, ctx->height, tiny, 16, 16);
+  free(full_gray);
+
+  // 2. Simple 3x3 Laplacian Kernel for edge detection
+  //  0 -1  0
+  // -1  4 -1
+  //  0 -1  0
+  uint64_t hash = 0;
+  int bit_idx = 0;
+  for (int y = 1; y < 15 && bit_idx < 64; y += 2) {
+    for (int x = 1; x < 15 && bit_idx < 64; x += 2) {
+      int center = tiny[y * 16 + x] * 4;
+      int neighbors = tiny[(y - 1) * 16 + x] + tiny[(y + 1) * 16 + x] +
+                      tiny[y * 16 + (x - 1)] + tiny[y * 16 + (x + 1)];
+      if (center - neighbors > 0)
+        hash |= (1ULL << bit_idx);
+      bit_idx++;
+    }
+  }
+  *out_hash = hash;
+  return PH_SUCCESS;
+}
diff --git a/src/hashes/whash.c b/src/hashes/whash.c
index 1295d8c..1bb595c 100644
--- a/src/hashes/whash.c
+++ b/src/hashes/whash.c
@@ -1,13 +1,12 @@
 #include "../internal.h"
 #include <stdlib.h>
 
-/* Simple Haar Wavelet Transform on a 1D array */
 static void haar_1d(double *data, int n) {
-  double temp[64]; // For 8x8
+  double temp[64];
   int h = n / 2;
   for (int i = 0; i < h; i++) {
-    temp[i] = (data[2 * i] + data[2 * i + 1]) / 1.414;
-    temp[i + h] = (data[2 * i] - data[2 * i + 1]) / 1.414;
+    temp[i] = (data[2 * i] + data[2 * i + 1]) / 1.4142;
+    temp[i + h] = (data[2 * i] - data[2 * i + 1]) / 1.4142;
   }
   for (int i = 0; i < n; i++)
     data[i] = temp[i];
@@ -16,7 +15,6 @@ static void haar_1d(double *data, int n) {
 PH_API ph_error_t ph_compute_whash(ph_context_t *ctx, uint64_t *out_hash) {
   if (!ctx || !ctx->is_loaded || !out_hash)
     return PH_ERR_INVALID_ARGUMENT;
-
   uint8_t gray[64];
   uint8_t *full_gray = malloc(ctx->width * ctx->height);
   if (!full_gray)
@@ -26,35 +24,30 @@ PH_API ph_error_t ph_compute_whash(ph_context_t *ctx, uint64_t *out_hash) {
   ph_resize_grayscale(full_gray, ctx->width, ctx->height, gray, 8, 8);
   free(full_gray);
 
-  double d_data[64];
+  double d[64];
   for (int i = 0; i < 64; i++)
-    d_data[i] = (double)gray[i];
+    d[i] = gray[i];
 
-  // 2D Haar Transform
   for (int i = 0; i < 8; i++)
-    haar_1d(&d_data[i * 8], 8); // Rows
-  for (int j = 0; j < 8; j++) { // Cols
+    haar_1d(&d[i * 8], 8);
+  for (int j = 0; j < 8; j++) {
     double col[8];
     for (int i = 0; i < 8; i++)
-      col[i] = d_data[i * 8 + j];
+      col[i] = d[i * 8 + j];
     haar_1d(col, 8);
     for (int i = 0; i < 8; i++)
-      d_data[i * 8 + j] = col[i];
+      d[i * 8 + j] = col[i];
   }
 
-  // The top-left value is the DC component. We use the average of the
-  // LL (Low-Low) sub-band to threshold.
   double sum = 0;
   for (int i = 0; i < 64; i++)
-    sum += d_data[i];
+    sum += d[i];
   double avg = sum / 64.0;
 
   uint64_t hash = 0;
-  for (int i = 0; i < 64; i++) {
-    if (d_data[i] > avg)
+  for (int i = 0; i < 64; i++)
+    if (d[i] > avg)
       hash |= (1ULL << i);
-  }
-
   *out_hash = hash;
   return PH_SUCCESS;
 }
diff --git a/tests/test_mhash.c b/tests/test_mhash.c
new file mode 100644
index 0000000..6b06c5e
--- /dev/null
+++ b/tests/test_mhash.c
@@ -0,0 +1,39 @@
+#include "libphash.h"
+#include "test_macros.h"
+#include <stdio.h>
+
+void test_mhash_logic() {
+  ph_context_t *ctx = NULL;
+  uint64_t hash_orig = 0, hash_mod = 0;
+
+  ASSERT_OK(ph_create(&ctx));
+
+  // Test 1: Base image
+  ASSERT_OK(ph_load_from_file(ctx, "tests/photo.jpeg"));
+  ASSERT_OK(ph_compute_mhash(ctx, &hash_orig));
+
+  // Test 2: Color changed image (MHash should be resistant to this as it tracks
+  // edges)
+  ASSERT_OK(ph_load_from_file(ctx, "tests/photo_color_changed.jpeg"));
+  ASSERT_OK(ph_compute_mhash(ctx, &hash_mod));
+
+  int dist = ph_hamming_distance(hash_orig, hash_mod);
+  printf("[MHash] Original: %llu, Color-Changed: %llu, Distance: %d\n",
+         (unsigned long long)hash_orig, (unsigned long long)hash_mod, dist);
+
+  // MHash tracks structural edges, so color shifts shouldn't change the edge
+  // skeleton much
+  if (dist > 12) {
+    fprintf(stderr, "MHash failed: too sensitive to color changes (dist: %d)\n",
+            dist);
+    exit(1);
+  }
+
+  ph_free(ctx);
+  printf("test_mhash: PASSED\n");
+}
+
+int main() {
+  test_mhash_logic();
+  return 0;
+}
diff --git a/tests/test_whash.c b/tests/test_whash.c
new file mode 100644
index 0000000..fea4fcc
--- /dev/null
+++ b/tests/test_whash.c
@@ -0,0 +1,37 @@
+#include "libphash.h"
+#include "test_macros.h"
+#include <stdio.h>
+
+void test_whash_logic() {
+  ph_context_t *ctx1 = NULL;
+  ph_context_t *ctx2 = NULL;
+  uint64_t hash1 = 0, hash2 = 0;
+
+  ASSERT_OK(ph_create(&ctx1));
+  ASSERT_OK(ph_create(&ctx2));
+
+  // Load original and a copy
+  ASSERT_OK(ph_load_from_file(ctx1, "tests/photo.jpeg"));
+  ASSERT_OK(ph_load_from_file(ctx2, "tests/photo_copy.jpeg"));
+
+  ASSERT_OK(ph_compute_whash(ctx1, &hash1));
+  ASSERT_OK(ph_compute_whash(ctx2, &hash2));
+
+  int dist = ph_hamming_distance(hash1, hash2);
+  printf("[WHash] Hash: %llu, Distance: %d\n", (unsigned long long)hash1, dist);
+
+  // WHash is very stable for copies
+  if (dist > 5) {
+    fprintf(stderr, "WHash distance too high for identical images: %d\n", dist);
+    exit(1);
+  }
+
+  ph_free(ctx1);
+  ph_free(ctx2);
+  printf("test_whash: PASSED\n");
+}
+
+int main() {
+  test_whash_logic();
+  return 0;
+}

</git_diff_staged>
</git_diffs>
