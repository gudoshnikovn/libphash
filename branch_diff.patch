diff --git a/Makefile b/Makefile
index 5801627..1bbe4f1 100644
--- a/Makefile
+++ b/Makefile
@@ -1,62 +1,47 @@
 CC = gcc
-# Added optimization flags and math support
 CFLAGS = -I./include -O3 -Wall -Wextra -fPIC
 LDFLAGS = -lm
 
+# Detect Architecture for SIMD
+UNAME_M := $(shell uname -m)
+ifeq ($(UNAME_M),x86_64)
+    CFLAGS += -msse4.2
+endif
+ifeq ($(UNAME_M),arm64)
+    CFLAGS += -march=armv8-a+simd
+endif
+
 LIB_NAME = libphash.a
 OBJ_DIR = obj
 SRC_DIR = src
 HASH_DIR = $(SRC_DIR)/hashes
 TEST_DIR = tests
 
-# Library source files (including new algorithms)
-SRCS = $(SRC_DIR)/core.c \
-       $(SRC_DIR)/image.c \
-       $(HASH_DIR)/ahash.c \
-       $(HASH_DIR)/dhash.c \
-       $(HASH_DIR)/phash.c \
-       $(HASH_DIR)/bmh.c \
-       $(HASH_DIR)/color_hash.c \
-       $(HASH_DIR)/radial.c \
-       $(HASH_DIR)/common.c
-
-# Map .c paths to .o paths
+SRCS = $(wildcard $(SRC_DIR)/*.c) $(wildcard $(HASH_DIR)/*.c)
 OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
 
-# Automatically find all test files
 TEST_SRCS = $(wildcard $(TEST_DIR)/test_*.c)
 TEST_BINS = $(TEST_SRCS:$(TEST_DIR)/%.c=%)
 
-.PHONY: all clean test
-
 all: $(LIB_NAME) $(TEST_BINS)
 
-# Build the static library
+# Debug target with AddressSanitizer
+debug: CFLAGS = -I./include -g -O0 -fsanitize=address,undefined -Wall -Wextra -fPIC
+debug: clean all
+
 $(LIB_NAME): $(OBJS)
-	@echo "Archiving $(LIB_NAME)..."
-	@ar rcs $@ $^
+	ar rcs $@ $^
 
-# Compile object files and recreate directory structure
 $(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
 	@mkdir -p $(dir $@)
 	$(CC) $(CFLAGS) -c $< -o $@
 
-# Build test executables
-# Order is critical: test source -> static library -> linker flags
 test_%: $(TEST_DIR)/test_%.c $(LIB_NAME)
 	$(CC) $(CFLAGS) $< $(LIB_NAME) -o $@ $(LDFLAGS)
 
-# Execute all tests sequentially
 test: $(TEST_BINS)
-	@echo "Starting test execution..."
-	@for test in $(TEST_BINS); do \
-		echo "Running $$test..."; \
-		./$$test || exit 1; \
-	done
-	@echo "------------------------------"
-	@echo "ALL TESTS PASSED SUCCESSFULLY"
-
-# Remove build artifacts
+	@for test in $(TEST_BINS); do ./$$test || exit 1; done
+	@echo "ALL TESTS PASSED"
+
 clean:
 	rm -rf $(OBJ_DIR) *.a test_*
-	@echo "Cleaned up build artifacts."
diff --git a/include/libphash.h b/include/libphash.h
index f61c966..73205ec 100644
--- a/include/libphash.h
+++ b/include/libphash.h
@@ -47,6 +47,11 @@
 extern "C" {
 #endif
 
+/**
+ * @brief Returns the library version string (e.g., "1.2.0").
+ */
+PH_API const char *ph_version(void);
+
 /**
  * @section Types and Errors
  */
@@ -153,12 +158,19 @@ PH_API PH_NODISCARD ph_error_t ph_compute_radial_hash(ph_context_t *ctx,
                                                       ph_digest_t *out_digest);
 
 /**
- * @brief Computes the Wavelet Hash (wHash).
- * Uses Haar Wavelets. Very robust to local image modifications.
+ * @brief Computes the Wavelet Hash (wHash) using Haar Wavelets.
+ * Excellent for local feature persistence.
  */
 PH_API PH_NODISCARD ph_error_t ph_compute_whash(ph_context_t *ctx,
                                                 uint64_t *out_hash);
 
+/**
+ * @brief Computes the Marr-Hildreth Hash (mHash).
+ * Based on edge detection. Very resistant to brightness/contrast changes.
+ */
+PH_API PH_NODISCARD ph_error_t ph_compute_mhash(ph_context_t *ctx,
+                                                uint64_t *out_hash);
+
 /**
  * @brief Calculates the Hamming distance between two 64-bit hashes.
  * @return Number of differing bits (0-64). 0 means identical hashes.
diff --git a/src/hashes/common.c b/src/hashes/common.c
index bdf167c..11702d6 100644
--- a/src/hashes/common.c
+++ b/src/hashes/common.c
@@ -2,12 +2,20 @@
 #include <math.h>
 #include <stdint.h>
 
+#if defined(__ARM_NEON) || defined(__ARM_NEON__)
+#include <arm_neon.h>
+#elif defined(__SSE4_2__)
+#include <nmmintrin.h>
+#endif
+
+PH_API const char *ph_version(void) { return "1.2.0"; }
+
 PH_API int ph_hamming_distance(uint64_t hash1, uint64_t hash2) {
   uint64_t x = hash1 ^ hash2;
-#if defined(_MSC_VER)
-  return (int)__popcnt64(x);
-#elif defined(__GNUC__) || defined(__clang__)
+#if defined(__GNUC__) || defined(__clang__)
   return __builtin_popcountll(x);
+#elif defined(_MSC_VER)
+  return (int)__popcnt64(x);
 #else
   int count = 0;
   while (x) {
@@ -20,33 +28,40 @@ PH_API int ph_hamming_distance(uint64_t hash1, uint64_t hash2) {
 
 PH_API int ph_hamming_distance_digest(const ph_digest_t *a,
                                       const ph_digest_t *b) {
-  if (!a || !b || a->bits != b->bits) {
+  if (!a || !b || a->bits != b->bits)
     return -1;
-  }
+  size_t len = (a->bits + 7) / 8;
+  int total = 0;
+  size_t i = 0;
 
-  int total_distance = 0;
-  size_t byte_count = (a->bits + 7) / 8;
+#if defined(__ARM_NEON) || defined(__ARM_NEON__)
+  uint16x8_t v_sum = vdupq_n_u16(0);
 
-  for (size_t i = 0; i < byte_count; i++) {
-    uint8_t x = a->data[i] ^ b->data[i];
+  for (; i + 16 <= len; i += 16) {
+    uint8x16_t va = vld1q_u8(&a->data[i]);
+    uint8x16_t vb = vld1q_u8(&b->data[i]);
+    uint8x16_t vxor = veorq_u8(va, vb);
+    uint8x16_t vcnt = vcntq_u8(vxor);
+    // Accumulate 8-bit counts into 16-bit lanes to prevent overflow
+    v_sum = vpadalq_u8(v_sum, vcnt);
+  }
+  // vaddlvq_u16 sums all lanes in the vector into a single 64-bit value
+  total = (int)vaddlvq_u16(v_sum);
+#endif
 
-    /* Use CPU-optimized population count where available */
-#if defined(_MSC_VER)
-    total_distance += (int)__popcnt16((uint16_t)x);
-#elif defined(__GNUC__) || defined(__clang__)
-    total_distance += __builtin_popcount(x);
+  for (; i < len; i++) {
+    uint8_t x = a->data[i] ^ b->data[i];
+#ifdef __GNUC__
+    total += __builtin_popcount(x);
 #else
-    /* Fallback: Kernighan's bit counting algorithm */
     while (x) {
       x &= (x - 1);
-      total_distance++;
+      total++;
     }
 #endif
   }
-
-  return total_distance;
+  return total;
 }
-
 PH_API double ph_l2_distance(const ph_digest_t *a, const ph_digest_t *b) {
   if (!a || !b || a->bits != b->bits)
     return -1.0;
diff --git a/src/hashes/mhash.c b/src/hashes/mhash.c
new file mode 100644
index 0000000..101d571
--- /dev/null
+++ b/src/hashes/mhash.c
@@ -0,0 +1,33 @@
+#include "../internal.h"
+#include <stdlib.h>
+
+PH_API ph_error_t ph_compute_mhash(ph_context_t *ctx, uint64_t *out_hash) {
+  if (!ctx || !ctx->is_loaded || !out_hash)
+    return PH_ERR_INVALID_ARGUMENT;
+
+  // 1. Resize to 16x16 to capture structural edges
+  uint8_t tiny[256];
+  uint8_t *full_gray = malloc(ctx->width * ctx->height);
+  ph_to_grayscale(ctx->data, ctx->width, ctx->height, ctx->channels, full_gray);
+  ph_resize_grayscale(full_gray, ctx->width, ctx->height, tiny, 16, 16);
+  free(full_gray);
+
+  // 2. Simple 3x3 Laplacian Kernel for edge detection
+  //  0 -1  0
+  // -1  4 -1
+  //  0 -1  0
+  uint64_t hash = 0;
+  int bit_idx = 0;
+  for (int y = 1; y < 15 && bit_idx < 64; y += 2) {
+    for (int x = 1; x < 15 && bit_idx < 64; x += 2) {
+      int center = tiny[y * 16 + x] * 4;
+      int neighbors = tiny[(y - 1) * 16 + x] + tiny[(y + 1) * 16 + x] +
+                      tiny[y * 16 + (x - 1)] + tiny[y * 16 + (x + 1)];
+      if (center - neighbors > 0)
+        hash |= (1ULL << bit_idx);
+      bit_idx++;
+    }
+  }
+  *out_hash = hash;
+  return PH_SUCCESS;
+}
diff --git a/src/hashes/whash.c b/src/hashes/whash.c
index 1295d8c..1bb595c 100644
--- a/src/hashes/whash.c
+++ b/src/hashes/whash.c
@@ -1,13 +1,12 @@
 #include "../internal.h"
 #include <stdlib.h>
 
-/* Simple Haar Wavelet Transform on a 1D array */
 static void haar_1d(double *data, int n) {
-  double temp[64]; // For 8x8
+  double temp[64];
   int h = n / 2;
   for (int i = 0; i < h; i++) {
-    temp[i] = (data[2 * i] + data[2 * i + 1]) / 1.414;
-    temp[i + h] = (data[2 * i] - data[2 * i + 1]) / 1.414;
+    temp[i] = (data[2 * i] + data[2 * i + 1]) / 1.4142;
+    temp[i + h] = (data[2 * i] - data[2 * i + 1]) / 1.4142;
   }
   for (int i = 0; i < n; i++)
     data[i] = temp[i];
@@ -16,7 +15,6 @@ static void haar_1d(double *data, int n) {
 PH_API ph_error_t ph_compute_whash(ph_context_t *ctx, uint64_t *out_hash) {
   if (!ctx || !ctx->is_loaded || !out_hash)
     return PH_ERR_INVALID_ARGUMENT;
-
   uint8_t gray[64];
   uint8_t *full_gray = malloc(ctx->width * ctx->height);
   if (!full_gray)
@@ -26,35 +24,30 @@ PH_API ph_error_t ph_compute_whash(ph_context_t *ctx, uint64_t *out_hash) {
   ph_resize_grayscale(full_gray, ctx->width, ctx->height, gray, 8, 8);
   free(full_gray);
 
-  double d_data[64];
+  double d[64];
   for (int i = 0; i < 64; i++)
-    d_data[i] = (double)gray[i];
+    d[i] = gray[i];
 
-  // 2D Haar Transform
   for (int i = 0; i < 8; i++)
-    haar_1d(&d_data[i * 8], 8); // Rows
-  for (int j = 0; j < 8; j++) { // Cols
+    haar_1d(&d[i * 8], 8);
+  for (int j = 0; j < 8; j++) {
     double col[8];
     for (int i = 0; i < 8; i++)
-      col[i] = d_data[i * 8 + j];
+      col[i] = d[i * 8 + j];
     haar_1d(col, 8);
     for (int i = 0; i < 8; i++)
-      d_data[i * 8 + j] = col[i];
+      d[i * 8 + j] = col[i];
   }
 
-  // The top-left value is the DC component. We use the average of the
-  // LL (Low-Low) sub-band to threshold.
   double sum = 0;
   for (int i = 0; i < 64; i++)
-    sum += d_data[i];
+    sum += d[i];
   double avg = sum / 64.0;
 
   uint64_t hash = 0;
-  for (int i = 0; i < 64; i++) {
-    if (d_data[i] > avg)
+  for (int i = 0; i < 64; i++)
+    if (d[i] > avg)
       hash |= (1ULL << i);
-  }
-
   *out_hash = hash;
   return PH_SUCCESS;
 }
diff --git a/tests/test_mhash.c b/tests/test_mhash.c
new file mode 100644
index 0000000..6b06c5e
--- /dev/null
+++ b/tests/test_mhash.c
@@ -0,0 +1,39 @@
+#include "libphash.h"
+#include "test_macros.h"
+#include <stdio.h>
+
+void test_mhash_logic() {
+  ph_context_t *ctx = NULL;
+  uint64_t hash_orig = 0, hash_mod = 0;
+
+  ASSERT_OK(ph_create(&ctx));
+
+  // Test 1: Base image
+  ASSERT_OK(ph_load_from_file(ctx, "tests/photo.jpeg"));
+  ASSERT_OK(ph_compute_mhash(ctx, &hash_orig));
+
+  // Test 2: Color changed image (MHash should be resistant to this as it tracks
+  // edges)
+  ASSERT_OK(ph_load_from_file(ctx, "tests/photo_color_changed.jpeg"));
+  ASSERT_OK(ph_compute_mhash(ctx, &hash_mod));
+
+  int dist = ph_hamming_distance(hash_orig, hash_mod);
+  printf("[MHash] Original: %llu, Color-Changed: %llu, Distance: %d\n",
+         (unsigned long long)hash_orig, (unsigned long long)hash_mod, dist);
+
+  // MHash tracks structural edges, so color shifts shouldn't change the edge
+  // skeleton much
+  if (dist > 12) {
+    fprintf(stderr, "MHash failed: too sensitive to color changes (dist: %d)\n",
+            dist);
+    exit(1);
+  }
+
+  ph_free(ctx);
+  printf("test_mhash: PASSED\n");
+}
+
+int main() {
+  test_mhash_logic();
+  return 0;
+}
diff --git a/tests/test_whash.c b/tests/test_whash.c
new file mode 100644
index 0000000..fea4fcc
--- /dev/null
+++ b/tests/test_whash.c
@@ -0,0 +1,37 @@
+#include "libphash.h"
+#include "test_macros.h"
+#include <stdio.h>
+
+void test_whash_logic() {
+  ph_context_t *ctx1 = NULL;
+  ph_context_t *ctx2 = NULL;
+  uint64_t hash1 = 0, hash2 = 0;
+
+  ASSERT_OK(ph_create(&ctx1));
+  ASSERT_OK(ph_create(&ctx2));
+
+  // Load original and a copy
+  ASSERT_OK(ph_load_from_file(ctx1, "tests/photo.jpeg"));
+  ASSERT_OK(ph_load_from_file(ctx2, "tests/photo_copy.jpeg"));
+
+  ASSERT_OK(ph_compute_whash(ctx1, &hash1));
+  ASSERT_OK(ph_compute_whash(ctx2, &hash2));
+
+  int dist = ph_hamming_distance(hash1, hash2);
+  printf("[WHash] Hash: %llu, Distance: %d\n", (unsigned long long)hash1, dist);
+
+  // WHash is very stable for copies
+  if (dist > 5) {
+    fprintf(stderr, "WHash distance too high for identical images: %d\n", dist);
+    exit(1);
+  }
+
+  ph_free(ctx1);
+  ph_free(ctx2);
+  printf("test_whash: PASSED\n");
+}
+
+int main() {
+  test_whash_logic();
+  return 0;
+}
